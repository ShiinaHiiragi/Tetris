<!DOCTYPE HTML>

<html>

<head>
  <title>Tetris</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Dependency Include Here -->
  <link href="./semantic/dist/semantic.min.css" rel="stylesheet" type="text/css">
  <script src="./semantic/dist/semantic.min.js"></script>

  <!-- Customized Resources -->
  <style>
    .panel {
      height: 90vh;
      width: 40vw;
      padding-top: 10vh;
      margin-left: 30vw;
    }

    .side {
      float: left;
      height: 80vh;
      width: calc((40vw - 40vh) / 2);
      /* background-color: lightcyan; */
    }

    .field {
      float: left;
      height: 80vh;
      width: 40vh;
      border: 1px solid rgb(225, 225, 225);
    }

    .cell {
      height: 5%;
      width: 10%;
      float: left;
      background-color: rgb(225, 225, 225);
      border: 1px solid rgb(240, 240, 240);
    }
  </style>
</head>

<body>
  <div class="panel">
    <div class="side" id="left-side">
      <!-- TODO: Hold & Score Here -->
    </div>
    <div class="field" id="field"></div>
    <div class="side" id="right-side">
      <!-- TODO: Next Pieces Here -->
      <div class="ui container">
        <button class="ui button" id="little-button" style="margin-left: 20px" onclick="initialize()"> Start </button>
      </div>
    </div>
  </div>
  <script>
    // TODO: delete these variables after releasing
    // var cellsColor = new Array(20);
    // for (var i = 0; i < 20; i += 1)
    //   cellsColor[i] = new Array(10).fill(0);
    // function setColor(element)
    // {
    //   var str = element.id.split("-");
    //   var index = (cellsColor[Number(str[1])][Number(str[2])] += 1);
    //   element.style.backgroundColor = Setting.color[index % 8];
    //   // used for manipulating transparency
    //   // element.style.opacity = "0.5";
    // }

    // TODO: initializing variables from settings.json
    var Setting =
    {
      color:
        [
          "rgb(225, 225, 225)", "rgb(252, 92, 101)",
          "rgb(253, 150, 68)", "rgb(254, 211, 48)",
          "rgb(38, 222, 129)", "rgb(69, 170, 242)",
          "rgb(75, 123, 236)", "rgb(165, 94, 234)"
        ],
      keyDownCode:
      {
        left: 37, right: 39, hold: 16,
        leftHalf: 88, rightHalf: 67,
        leftQuarter: 90, rightQuarter: 86,
        hardDrop: 38, softDrop: 40
      },
      fallTime: 800,
      lockTime: 500
    }
    // process raw setting in the file
    // fallTime: 1 ~ 10; 1: 100ms, 10: 10ms
    // lockTime: 1 ~ 10; 1: 1000ms, 10: 100ms
    // Setting.fallTime = 110 - Setting.fallTime * 10;
    // Setting.lockTime = 1100 - Setting.lockTime * 100;

    // System: important logic data, which cannot be changed by user
    var System =
    {
      pieces:
        [
          null,
          [
            [[1, 0], [1, -1], [0, -1]], [[0, -1], [-1, -1], [-1, 0]],
            [[-1, 0], [-1, 1], [0, 1]], [[0, 1], [1, 1], [1, 0]]
          ],
          [
            [[0, 1], [0, -1], [-1, 1]], [[1, 0], [-1, 0], [1, 1]],
            [[0, -1], [0, 1], [1, -1]], [[-1, 0], [1, 0], [-1, -1]]
          ],
          [
            [[0, 1], [0, -1], [-1, -1]], [[1, 0], [-1, 0], [-1, 1]],
            [[0, -1], [0, 1], [1, 1]], [[-1, 0], [1, 0], [1, -1]]
          ],
          [
            [[0, 1], [0, -1], [-1, 0]], [[1, 0], [-1, 0], [0, 1]],
            [[0, -1], [0, 1], [1, 0]], [[-1, 0], [1, 0], [0, -1]]
          ],
          [
            [[0, -1], [-1, 0], [-1, 1]], [[-1, 0], [0, 1], [1, 1]],
            [[0, 1], [1, 0], [1, -1]], [[1, 0], [0, -1], [-1, -1]]
          ],
          [
            [[0, 1], [-1, -1], [-1, 0]], [[1, 0], [-1, 1], [0, 1]],
            [[0, -1], [1, 1], [1, 0]], [[-1, 0], [1, -1], [0, -1]]
          ],
          [
            [[0, 1], [0, -1], [0, -2]], [[1, 0], [-1, 0], [-2, 0]],
            [[0, -1], [0, 1], [0, 2]], [[-1, 0], [1, 0], [2, 0]]
          ]
        ],
      // kickWall = [I_clock, I_counter, JLSTZ_clock, JLSTZ_counter]
      kickWall:
      [
        [
          [[0, 1], [0, -2], [2, 1], [-1, -2]], [[0, -2], [0, 1], [1, -2], [-2, 1]],
          [[0, -1], [0, 2], [-2, -1], [1, 2]], [[0, 2], [0, -1], [-1, 2], [2, -1]]
        ],
        [
          [[0, 2], [0, -1], [-1, 2], [2, -1]], [[0, 1], [0, -2], [2, 1], [-1, -2]],
          [[0, -2], [0, 1], [1, -2], [-2, 1]], [[0, -1], [0, 2], [-2, -1], [1, 2]]
        ],
        [
          [[0, -1], [1, -1], [-2, 0], [-2, -1]], [[0, -1], [-1, -1], [2, 0], [2, -1]],
          [[0, 1], [1, 1], [-2, 0], [-2, 1]], [[0, 1], [-1, 1], [2, 0], [2, 1]]
        ],
        [
          [[0, 1], [1, 1], [-2, 0], [-2, 1]], [[0, -1], [-1, -1], [2, 0], [2, -1]],
          [[0, -1], [1, -1], [-2, 0], [-2, -1]], [[0, 1], [-1, 1], [2, 0], [2, 1]]
        ]
      ],
      align: [[1, 0], [0, -1], [-1, 0], [0, 1], [1, 0], [0, -1]],
      positionInit: [null, [2, 5], [3, 4], [3, 4], [3, 4], [3, 4], [3, 4], [3, 5]],
      lastSpin: false,
      falldownClock: null,
      lockdownClock: null,
      firstBag: null,
      secondBag: null,
      shuffle: null,
      shuffleInit: function ()
      {
        this.shufflePointer = 0;
        this.firstBag = [1, 2, 3, 4, 5, 6, 7].sort(() => { return 0.5 - Math.random(); });
        this.secondBag = [1, 2, 3, 4, 5, 6, 7].sort(() => { return 0.5 - Math.random(); });
        this.shuffle = this.firstBag.concat(this.secondBag);
      },
      shuffleRefresh: function()
      {
        this.shufflePointer = 0;
        this.firstBag = this.secondBag;
        this.secondBag = null;
        this.secondBag = [1, 2, 3, 4, 5, 6, 7].sort(() => { return 0.5 - Math.random(); });
        this.shuffle = this.firstBag.concat(this.secondBag);
      },
      shufflePointer: 0
    }

    // Cite: the element in the HTML DOM
    var Cite =
    {
      // field: a cite for field
      field: document.getElementById("field"),
      // cells: a two-dimension array citing the 10 Ã— 20 grid
      cells: new Array(20)
    }
    // process the raw element in the DOM
    for (var i = 0; i < 20; i += 1)
      Cite.cells[i] = new Array(10).fill(null);
    for (var i = 0; i < 20; i += 1)
      for (var j = 0; j < 10; j += 1)
      {
        Cite.cells[i][j] = document.createElement("div");
        Cite.cells[i][j].className = "cell";
        Cite.cells[i][j].id = "cell-" + i.toString() + "-" + j.toString();
        // TODO: delete this arrtibute before realeasing
        Cite.cells[i][j].setAttribute("onclick", "setColor(this)")
        Cite.field.append(Cite.cells[i][j]);
      }

    // Panel: The cell and the data of Tetris
    var Panel = {cells: new Array(24), score: 0, line: 0}
    // process raw panel data
    for (var i = 0; i < 24; i += 1)
      Panel.cells[i] = new Array(10).fill(0);

    // Piece: The block available for manipupating
    class Piece
    {
      constructor(pos, type, direct)
      {
        // the position of top left corner is [4, 0]
        this.position = pos;
        // type: 1 ~ 7; O, L, J, T, S, Z, I
        this.type = type;
        // direction: 0 ~ 3
        this.direction = direct;
      }

      init(index)
      {
        this.type = index;
        this.direction = 0;
        this.position = [System.positionInit[index][0], System.positionInit[index][1]];
      }

      copy(right)
      {
        this.position = [right.position[0], right.position[1]];
        this.type = right.type;
        this.direction = right.direction;
      }

      // draw the piece on the panel and the array
      // clear: true: print, false: clear
      // heap: true: solid, false: not solid
      draw(clear, heap)
      {
        var high = true;
        var center = [this.position[0] - 4, this.position[1]];
        var bias = System.pieces[this.type][this.direction];
        if (center[0] >= 0)
        {
          Cite.cells[center[0]][center[1]].style.backgroundColor = Setting.color[clear ? this.type : 0];
          high = false;
        }
        Panel.cells[center[0] + 4][center[1]] = clear ? (heap ? 2 : 1) : 0;
        for (var index = 0; index < 3; index += 1) {
          var bias = System.pieces[this.type][this.direction][index];
          Panel.cells[center[0] + bias[0] + 4][center[1] + bias[1]] = clear ? (heap ? 2 : 1) : 0;
          if (center[0] + bias[0] >= 0)
          {
            Cite.cells[center[0] + bias[0]][center[1] + bias[1]].style.backgroundColor =
              Setting.color[clear ? this.type : 0];
            high = false;
          }
        }
        return high;
      }

      // check if there is any collision
      // out of the panel or existed pieces
      check()
      {
        var center = [this.position[0] - 4, this.position[1]];
        var bias = System.pieces[this.type][this.direction];
        if (center[0] < -4 || center[0] > 19 || center[1] < 0 || center[1] > 9) return false;
        if (Panel.cells[center[0] + 4][center[1]] == 2) return false;
        for (var index = 0; index < 3; index += 1)
        {
          var bias = System.pieces[this.type][this.direction][index];
          if (center[0] + bias[0] < -4 || center[0] + bias[0] > 19 ||
            center[1] + bias[1] < 0 || center[1] + bias[1] > 9) return false;
          if (Panel.cells[center[0] + bias[0] + 4][center[1] + bias[1]] == 2) return false;
        }
        return true;
      }

      // pos: a bias array (down: [1, 0])
      shift(next, pos)
      {
        next.position = [this.position[0] + pos[0], this.position[1] + pos[1]];
        next.type = this.type;
        next.direction = this.direction;
        return next.check();
      }

      // direct: 1(90) / 2(180) / 3(-90)
      // right: true: clockwise, false: counterclockwise
      rotate(next, direct, right)
      {
        var kickType = null;
        next.position = [this.position[0], this.position[1]];
        next.type = this.type;
        next.direction = (this.direction + direct) % 4;
        if (this.type == 1 || this.type == 7)
          for (var index = 0; index < direct; index += 1)
          {
            next.position[0] += System.align[this.direction + index][0];
            next.position[1] += System.align[this.direction + index][1];
          }
        if (next.check()) return true;
        else if (this.type == 7) kickType = (right ? System.kickWall[0] : System.kickWall[1]);
        else kickType = (right ? System.kickWall[2] : System.kickWall[3]);
        for (var index = 0; index < 4; index += 1)
        {
          next.shift(Pieces.try, kickType[next.direction][index]);
          if (Pieces.try.check())
          {
            next.copy(Pieces.try);
            return true;
          }
        }
        return false;
      }
    }
    var Pieces = {now: new Piece(), next: new Piece(), try: new Piece(), preview: new Piece()}

    function updateNow()
    {
      Pieces.now.draw(false, false);
      Pieces.next.draw(true, false);
      Pieces.now.copy(Pieces.next);
    }

    function naturalFalldown()
    {
      if (Pieces.now.shift(Pieces.next, [1, 0])) updateNow()
      else
      {
        console.log("lockdownTime");
        System.falldownClock = window.clearInterval(System.falldownClock);
        System.lockdownClock = window.setTimeout(lockdownDelay, Setting.lockTime);
      }
    }

    function gameOver()
    {
      if (System.falldownClock != undefined)
        System.falldownClock = window.clearInterval(System.falldownClock);
      if (System.lockdownClock != undefined)
        System.lockdownClock = window.clearTimeout(System.lockdownClock);
      // TODO: other behavior
      alert("Game Over.");
    }

    function lockdownDelay()
    {
      if (Pieces.now.shift(Pieces.next, [1, 0]))
      {
        updateNow();
        System.lockdownClock = window.setTimeout(lockdownDelay, Setting.lockTime);
      }
      else if (Pieces.now.draw(true, true)) gameOver();
      else
      {
        Pieces.now.init(System.shuffle[++System.shufflePointer]);
        if (System.shufflePointer == 7) System.shuffleRefresh();
        if (Pieces.now.check())
        {
          Pieces.now.draw(true, false);
          System.falldownClock = window.setInterval(naturalFalldown, Setting.fallTime);
        }
        else gameOver();
      }
    }

    function keyboardEvent(event)
    {
      if (event.keyCode == Setting.keyDownCode.leftQuarter ||
          event.keyCode == Setting.keyDownCode.leftHalf ||
          event.keyCode == Setting.keyDownCode.rightHalf ||
          event.keyCode == Setting.keyDownCode.rightQuarter)
      {
        // used for judging T-Spin
        System.lastSpin = true;
        // reset lockdownClock
        if (System.falldownClock == undefined)
        {
          System.lockdownClock = window.clearTimeout(System.lockdownClock);
          System.lockdownClock = window.setTimeout(lockdownDelay, Setting.lockTime);
        }
        var second;
        if (event.keyCode == Setting.keyDownCode.rightQuarter) second = 1;
        else if (event.keyCode == Setting.keyDownCode.leftQuarter) second = 3;
        else second = 2;
        var third = (event.keyCode == Setting.keyDownCode.rightHalf ||
                     event.keyCode == Setting.keyDownCode.rightQuarter);
        if (Pieces.now.rotate(Pieces.next, second, third)) updateNow()
      }
      else if (event.keyCode == Setting.keyDownCode.left ||
               event.keyCode == Setting.keyDownCode.right)
      {
        System.lastSpin = false;
        if (System.falldownClock == undefined)
        {
          System.lockdownClock = window.clearTimeout(System.lockdownClock);
          System.lockdownClock = window.setTimeout(lockdownDelay, Setting.lockTime);
        }
        if (Pieces.now.shift(Pieces.next, [0, (event.keyCode == Setting.keyDownCode.left ? -1 : 1)]))
          updateNow();
      }
      else if (event.keyCode == Setting.keyDownCode.hold ||
               event.keyCode == Setting.keyDownCode.softDrop ||
               event.keyCode == Setting.keyDownCode.hardDrop)
      {
        System.lastSpin = false;
        if (event.keyCode == Setting.keyDownCode.softDrop)
        {
          if (Pieces.now.shift(Pieces.next, [1, 0]))
            updateNow();
        }
        else if (event.keyCode == Setting.keyDownCode.hardDrop)
        {
          Pieces.next.copy(Pieces.now);
          while (Pieces.next.shift(Pieces.try, [1, 0]))
            Pieces.next.copy(Pieces.try);
          updateNow();
          System.falldownClock = window.clearInterval(System.falldownClock);
          lockdownDelay();
        }
      }
    }

    function initialize()
    {
      document.getElementById("little-button").style.visibility = "hidden";
      System.shuffleInit();
      Pieces.now.init(System.shuffle[System.shufflePointer]);
      Pieces.now.draw(true, false);
      document.addEventListener('keydown', keyboardEvent);
      System.falldownClock = window.setInterval(naturalFalldown, Setting.fallTime);
    }
  </script>
</body>

</html>